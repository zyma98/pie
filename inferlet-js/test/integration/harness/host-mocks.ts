// Host mock implementations for WASM component testing
// These provide the WIT interface implementations that the WASM component imports

export interface MockOptions {
  /** CLI arguments to provide */
  args?: string[];
  /** Available models by name */
  models?: Record<string, ModelConfig>;
  /** Capture sent output */
  outputCapture?: string[];
  /** KV store initial state */
  kvStore?: Map<string, string>;
}

export interface ModelConfig {
  name: string;
  traits?: string[];
  description?: string;
  promptTemplate?: string;
  stopTokens?: string[];
  kvPageSize?: number;
}

// Resource ID counter for managing WIT resources
let resourceIdCounter = 0;

/**
 * Create host mock implementations for all required WIT interfaces.
 * These are passed to the instantiate() function generated by jco transpile.
 */
export function createHostMocks(options: MockOptions = {}) {
  const outputCapture = options.outputCapture ?? [];
  const kvStore = options.kvStore ?? new Map<string, string>();
  const models = options.models ?? {
    'mock-model': {
      name: 'mock-model',
      traits: ['input_text', 'output_text', 'tokenize'],
      description: 'Mock model for testing',
      promptTemplate: '{% for msg in messages %}{{ msg.role }}: {{ msg.content }}\n{% endfor %}{% if add_generation_prompt %}assistant: {% endif %}',
      stopTokens: ['<|eot_id|>'],
      kvPageSize: 256,
    },
  };
  const args = options.args ?? [];

  // Track created resources
  const modelResources = new Map<number, ModelConfig>();
  const queueResources = new Map<number, { serviceId: number }>();
  const tokenizerResources = new Map<number, { model: ModelConfig }>();

  // Pollable mock - always ready for simplicity
  class Pollable {
    ready() { return true; }
    block() { /* no-op */ }
  }

  // Stream mocks for WASI IO
  class InputStream {
    read(_len: bigint) { return new Uint8Array(0); }
    blockingRead(_len: bigint) { return new Uint8Array(0); }
    skip(_len: bigint) { return 0n; }
    blockingSkip(_len: bigint) { return 0n; }
    subscribe() { return new Pollable(); }
  }

  class OutputStream {
    checkWrite() { return 1024n; }
    write(contents: Uint8Array) { /* discard */ }
    blockingWriteAndFlush(contents: Uint8Array) { /* discard */ }
    flush() { /* no-op */ }
    blockingFlush() { /* no-op */ }
    writeZeroes(_len: bigint) { /* no-op */ }
    blockingWriteZeroesAndFlush(_len: bigint) { /* no-op */ }
    splice(_src: any, _len: bigint) { return 0n; }
    blockingSplice(_src: any, _len: bigint) { return 0n; }
    subscribe() { return new Pollable(); }
  }

  // Error mock for WASI IO
  class WasiError {
    toDebugString() { return 'mock-error'; }
  }

  // Terminal mocks
  class TerminalInput { }
  class TerminalOutput { }

  // WASI poll interface (both versioned and unversioned keys)
  const wasiIoPoll = {
    Pollable,
    poll: (pollables: Pollable[]) => {
      const ready: number[] = [];
      for (let i = 0; i < pollables.length; i++) {
        if (pollables[i].ready()) {
          ready.push(i);
        }
      }
      return new Uint32Array(ready.length > 0 ? ready : [0]);
    },
  };

  // WASI streams interface
  const wasiIoStreams = {
    InputStream,
    OutputStream,
  };

  // WASI error interface
  const wasiIoError = {
    Error: WasiError,
  };

  // Create mock streams for stdio
  const stdinStream = new InputStream();
  const stdoutStream = new OutputStream();
  const stderrStream = new OutputStream();

  // Create the host imports object that matches jco's expected structure
  return {
    // wasi:io/poll (both versioned and unversioned)
    'wasi:io/poll@0.2.4': wasiIoPoll,
    'wasi:io/poll': wasiIoPoll,

    // wasi:io/streams
    'wasi:io/streams@0.2.4': wasiIoStreams,
    'wasi:io/streams': wasiIoStreams,

    // wasi:io/error
    'wasi:io/error@0.2.4': wasiIoError,
    'wasi:io/error': wasiIoError,

    // wasi:cli/stdin, stdout, stderr
    'wasi:cli/stdin@0.2.4': { getStdin: () => stdinStream },
    'wasi:cli/stdin': { getStdin: () => stdinStream },
    'wasi:cli/stdout@0.2.4': { getStdout: () => stdoutStream },
    'wasi:cli/stdout': { getStdout: () => stdoutStream },
    'wasi:cli/stderr@0.2.4': { getStderr: () => stderrStream },
    'wasi:cli/stderr': { getStderr: () => stderrStream },

    // wasi:cli/terminal
    'wasi:cli/terminal-input@0.2.4': { TerminalInput },
    'wasi:cli/terminal-input': { TerminalInput },
    'wasi:cli/terminal-output@0.2.4': { TerminalOutput },
    'wasi:cli/terminal-output': { TerminalOutput },
    'wasi:cli/terminal-stdin@0.2.4': { getTerminalStdin: () => undefined },
    'wasi:cli/terminal-stdin': { getTerminalStdin: () => undefined },
    'wasi:cli/terminal-stdout@0.2.4': { getTerminalStdout: () => undefined },
    'wasi:cli/terminal-stdout': { getTerminalStdout: () => undefined },
    'wasi:cli/terminal-stderr@0.2.4': { getTerminalStderr: () => undefined },
    'wasi:cli/terminal-stderr': { getTerminalStderr: () => undefined },

    // wasi:clocks/monotonic-clock
    'wasi:clocks/monotonic-clock@0.2.4': {
      now: () => BigInt(Date.now()) * 1000000n, // nanoseconds
      resolution: () => 1000000n, // 1ms resolution
      subscribeDuration: (_duration: bigint) => new Pollable(),
      subscribeInstant: (_instant: bigint) => new Pollable(),
    },
    'wasi:clocks/monotonic-clock': {
      now: () => BigInt(Date.now()) * 1000000n,
      resolution: () => 1000000n,
      subscribeDuration: (_duration: bigint) => new Pollable(),
      subscribeInstant: (_instant: bigint) => new Pollable(),
    },

    // wasi:clocks/wall-clock
    'wasi:clocks/wall-clock@0.2.4': {
      now: () => ({ seconds: BigInt(Math.floor(Date.now() / 1000)), nanoseconds: 0 }),
      resolution: () => ({ seconds: 0n, nanoseconds: 1000000 }),
    },
    'wasi:clocks/wall-clock': {
      now: () => ({ seconds: BigInt(Math.floor(Date.now() / 1000)), nanoseconds: 0 }),
      resolution: () => ({ seconds: 0n, nanoseconds: 1000000 }),
    },

    // wasi:random/random
    'wasi:random/random@0.2.4': {
      getRandomBytes: (len: bigint) => {
        const bytes = new Uint8Array(Number(len));
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = Math.floor(Math.random() * 256);
        }
        return bytes;
      },
      getRandomU64: () => BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)),
    },
    'wasi:random/random': {
      getRandomBytes: (len: bigint) => {
        const bytes = new Uint8Array(Number(len));
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = Math.floor(Math.random() * 256);
        }
        return bytes;
      },
      getRandomU64: () => BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)),
    },

    // wasi:filesystem/preopens - minimal stub
    'wasi:filesystem/preopens@0.2.4': { getDirectories: () => [] },
    'wasi:filesystem/preopens': { getDirectories: () => [] },

    // wasi:filesystem/types - minimal stub
    'wasi:filesystem/types@0.2.4': {
      Descriptor: class Descriptor { },
      filesystemErrorCode: () => undefined,
    },
    'wasi:filesystem/types': {
      Descriptor: class Descriptor { },
      filesystemErrorCode: () => undefined,
    },

    // wasi:http/types - minimal stubs
    'wasi:http/types@0.2.4': {
      Fields: class Fields { },
      FutureIncomingResponse: class FutureIncomingResponse { },
      IncomingBody: class IncomingBody { },
      IncomingRequest: class IncomingRequest { },
      IncomingResponse: class IncomingResponse { },
      OutgoingBody: class OutgoingBody { },
      OutgoingRequest: class OutgoingRequest { },
      OutgoingResponse: class OutgoingResponse { },
      RequestOptions: class RequestOptions { },
      ResponseOutparam: class ResponseOutparam { },
    },
    'wasi:http/types': {
      Fields: class Fields { },
      FutureIncomingResponse: class FutureIncomingResponse { },
      IncomingBody: class IncomingBody { },
      IncomingRequest: class IncomingRequest { },
      IncomingResponse: class IncomingResponse { },
      OutgoingBody: class OutgoingBody { },
      OutgoingRequest: class OutgoingRequest { },
      OutgoingResponse: class OutgoingResponse { },
      RequestOptions: class RequestOptions { },
      ResponseOutparam: class ResponseOutparam { },
    },

    // wasi:http/outgoing-handler - minimal stub
    'wasi:http/outgoing-handler@0.2.4': {
      handle: () => { throw new Error('HTTP not supported in mock'); },
    },
    'wasi:http/outgoing-handler': {
      handle: () => { throw new Error('HTTP not supported in mock'); },
    },

    // inferlet:core/common
    'inferlet:core/common': {
      Blob: class Blob {
        #data: Uint8Array;
        constructor(init: number[]) {
          this.#data = new Uint8Array(init);
        }
        read(offset: bigint, n: bigint) {
          const start = Number(offset);
          const len = Number(n);
          return Array.from(this.#data.slice(start, start + len));
        }
        size() {
          return BigInt(this.#data.length);
        }
      },

      BlobResult: class BlobResult {
        #value: any;
        constructor(value: any) { this.#value = value; }
        pollable() { return new Pollable(); }
        get() { return this.#value; }
      },

      Model: class Model {
        #id: number;
        #config: ModelConfig;

        constructor(config: ModelConfig) {
          this.#id = ++resourceIdCounter;
          this.#config = config;
          modelResources.set(this.#id, config);
        }

        getName() { return this.#config.name; }
        getTraits() { return this.#config.traits ?? []; }
        getDescription() { return this.#config.description ?? ''; }
        getPromptTemplate() { return this.#config.promptTemplate ?? ''; }
        getStopTokens() { return this.#config.stopTokens ?? []; }
        getServiceId() { return 1; }
        getKvPageSize() { return this.#config.kvPageSize ?? 256; }

        createQueue() {
          const queueId = ++resourceIdCounter;
          queueResources.set(queueId, { serviceId: 1 });
          return new (createHostMocks(options)['inferlet:core/common'].Queue as any)();
        }
      },

      Queue: class Queue {
        #id: number;
        #serviceId: number;

        constructor() {
          this.#id = ++resourceIdCounter;
          this.#serviceId = 1;
        }

        getServiceId() { return this.#serviceId; }
        synchronize() {
          return {
            pollable: () => new Pollable(),
            get: () => true,
          };
        }
        setPriority(_priority: string) { /* no-op */ }
        debugQuery(query: string) {
          return {
            pollable: () => new Pollable(),
            get: () => `mock-debug: ${query}`,
          };
        }
      },

      SynchronizationResult: class SynchronizationResult {
        pollable() { return new Pollable(); }
        get() { return true; }
      },

      DebugQueryResult: class DebugQueryResult {
        #value: string;
        constructor(value: string) { this.#value = value; }
        pollable() { return new Pollable(); }
        get() { return this.#value; }
      },

      allocateResources: (_queue: any, _resourceType: number, count: number) => {
        const ptrs: number[] = [];
        for (let i = 0; i < count; i++) {
          ptrs.push(++resourceIdCounter);
        }
        return ptrs;
      },

      deallocateResources: () => { /* no-op */ },
      getAllExportedResources: () => [],
      releaseExportedResources: () => { /* no-op */ },
      exportResources: () => { /* no-op */ },
      importResources: () => [],
    },

    // inferlet:core/runtime
    'inferlet:core/runtime': {
      getVersion: () => '1.0.0-test',
      getInstanceId: () => `test-instance-${Date.now()}`,
      getArguments: () => args,
      setReturn: (_value: string) => { /* no-op */ },

      getModel: (name: string) => {
        const config = models[name];
        if (!config) return undefined;
        const Model = createHostMocks(options)['inferlet:core/common'].Model as any;
        return new Model(config);
      },

      getAllModels: () => Object.keys(models),

      getAllModelsWithTraits: (traits: string[]) => {
        return Object.entries(models)
          .filter(([_, config]) => {
            const modelTraits = config.traits ?? [];
            return traits.every((t) => modelTraits.includes(t));
          })
          .map(([name]) => name);
      },

      debugQuery: (query: string) => {
        const DebugQueryResult = createHostMocks(options)['inferlet:core/common'].DebugQueryResult as any;
        return new DebugQueryResult(`runtime-debug: ${query}`);
      },
    },

    // inferlet:core/message
    'inferlet:core/message': {
      Subscription: class Subscription {
        pollable() { return new Pollable(); }
        get() { return undefined; }
        unsubscribe() { /* no-op */ }
      },

      ReceiveResult: class ReceiveResult {
        pollable() { return new Pollable(); }
        get() { return undefined; }
      },

      send: (message: string) => {
        outputCapture.push(message);
      },

      receive: () => ({
        pollable: () => new Pollable(),
        get: () => undefined,
      }),

      sendBlob: (_blob: any) => { /* no-op */ },
      receiveBlob: () => ({
        pollable: () => new Pollable(),
        get: () => undefined,
      }),

      broadcast: (_topic: string, _message: string) => { /* no-op */ },
      subscribe: (_topic: string) => ({
        pollable: () => new Pollable(),
        get: () => undefined,
        unsubscribe: () => { /* no-op */ },
      }),
    },

    // inferlet:core/tokenize
    'inferlet:core/tokenize': {
      Tokenizer: class Tokenizer {
        #model: ModelConfig;

        constructor(model: ModelConfig) {
          this.#model = model;
        }

        // Simple character-based tokenization for testing
        tokenize(text: string) {
          // Handle special tokens
          const specialTokens: Record<string, number> = {
            '<|eot_id|>': 128009,
            '<|end_of_text|>': 128001,
            '<|start_header_id|>': 128006,
            '<|end_header_id|>': 128007,
          };

          const tokens: number[] = [];
          let remaining = text;

          while (remaining.length > 0) {
            let found = false;
            for (const [special, id] of Object.entries(specialTokens)) {
              if (remaining.startsWith(special)) {
                tokens.push(id);
                remaining = remaining.slice(special.length);
                found = true;
                break;
              }
            }
            if (!found) {
              tokens.push(remaining.charCodeAt(0));
              remaining = remaining.slice(1);
            }
          }

          return tokens;
        }

        detokenize(tokenIds: number[]) {
          const specialTokens: Record<number, string> = {
            128009: '<|eot_id|>',
            128001: '<|end_of_text|>',
            128006: '<|start_header_id|>',
            128007: '<|end_header_id|>',
          };

          return tokenIds
            .map((id) => specialTokens[id] ?? String.fromCharCode(id))
            .join('');
        }

        getVocabs() {
          // Return minimal vocab for testing
          const ids = new Uint32Array([65, 66, 67]); // A, B, C
          const bytes = [[65], [66], [67]];
          return [ids, bytes];
        }

        getSplitRegex() {
          return "\\s+|[^\\s]+";
        }

        getSpecialTokens() {
          const ids = new Uint32Array([128009, 128001]);
          const bytes = [
            Array.from(new TextEncoder().encode('<|eot_id|>')),
            Array.from(new TextEncoder().encode('<|end_of_text|>')),
          ];
          return [ids, bytes];
        }
      },

      getTokenizer: (model: any) => {
        const config = model.getName
          ? models[model.getName()]
          : models['mock-model'];
        const Tokenizer = createHostMocks(options)['inferlet:core/tokenize'].Tokenizer as any;
        return new Tokenizer(config ?? { name: 'mock-model' });
      },
    },

    // inferlet:core/kvs
    'inferlet:core/kvs': {
      storeGet: (key: string) => kvStore.get(key),
      storeSet: (key: string, value: string) => { kvStore.set(key, value); },
      storeDelete: (key: string) => { kvStore.delete(key); },
      storeExists: (key: string) => kvStore.has(key),
      storeListKeys: () => [...kvStore.keys()],
    },

    // inferlet:core/forward - minimal stub for now
    'inferlet:core/forward': {
      ForwardPass: class ForwardPass {
        execute() {
          return {
            pollable: () => new Pollable(),
            getTokens: () => new Uint32Array([100]),
            getDistributions: () => null,
          };
        }
      },

      ForwardPassResult: class ForwardPassResult {
        pollable() { return new Pollable(); }
        getTokens() { return new Uint32Array([100]); }
        getDistributions() { return null; }
      },

      createForwardPass: () => ({
        execute: () => ({
          pollable: () => new Pollable(),
          getTokens: () => new Uint32Array([100]),
          getDistributions: () => null,
        }),
      }),

      attentionMask: () => { /* no-op */ },
      kvCache: () => { /* no-op */ },
      inputEmbeddings: () => { /* no-op */ },
      inputTokens: () => { /* no-op */ },
      outputEmbeddings: () => { /* no-op */ },
      outputDistributions: () => { /* no-op */ },
      outputTokens: () => { /* no-op */ },
      outputTokensTopK: () => { /* no-op */ },
      outputTokensTopP: () => { /* no-op */ },
      outputTokensMinP: () => { /* no-op */ },
      outputTokensTopKTopP: () => { /* no-op */ },
    },

    // inferlet:image/image - minimal stubs
    'inferlet:image/image': {
      calculateEmbedSize: () => 0,
      embedImage: () => { throw new Error('Image embedding not supported in mock'); },
    },

    // inferlet:adapter/common - minimal stubs
    'inferlet:adapter/common': {
      downloadAdapter: () => { throw new Error('Adapter download not supported in mock'); },
      setAdapter: () => { /* no-op */ },
      uploadAdapter: () => { throw new Error('Adapter upload not supported in mock'); },
    },

    // inferlet:zo/evolve - minimal stubs
    'inferlet:zo/evolve': {
      initializeAdapter: () => { /* no-op */ },
      setAdapterSeed: () => { /* no-op */ },
      updateAdapter: () => { /* no-op */ },
    },
  };
}

/**
 * Reset resource ID counter (call between tests for isolation)
 */
export function resetResourceIds() {
  resourceIdCounter = 0;
}
